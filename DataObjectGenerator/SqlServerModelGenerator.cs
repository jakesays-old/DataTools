using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;
using Std.Utility;
using Std.Utility.Process;

namespace Std.DataTools
{
	public class SqlServerModelGenerator : MsSqlDataModelBase
	{
		public string ConnectionString { get; set; }

		public string DatabaseServer { get; set; }

		public string DatabaseUsername { get; set; }

		public string DatabasePassword { get; set; }
		
		public bool GenerateDataContextClass { get; set; }

		public string BaseDataContextClass { get; set; }

		public bool PluralizeClassNames { get; set; }

		public bool SingularizeClassNames { get; set; }

		public bool PluralizeDataContextPropertyNames { get; set; }

		public bool SingularizeDataContextPropertyNames { get; set; }

		public string DatabaseName { get; set; }

		public string DataContextName { get; set; }

		public string DataNamespace { get; set; }

		public string PocoNamespace { get; set; }

		public string AdapterNamespace { get; set; }

		public string BaseEntityClass { get; set; }

		public string OneToManyDataObjectAssociationType { get; set; }

		public string OneToManyPocoAssociationType { get; set; }

		public string OwnerToInclude { get; set; }

		public string[] DatabaseQuote { get; set; }

		public bool RenderField { get; set; }

		public bool RenderBackReferences { get; set; }

		public bool RenderForeignKeys { get; set; }

		public string DataObjectSuffix { get; set; }

		public string PocoSuffix { get; set; }

		public string AdapterSuffix { get; set; }

		public bool GeneratePartialClasses { get; set; }

		public List<string> IncludeTables { get; set; }

		public string IncludeTablePattern { get; set; }

		public bool GeneratePocos { get; set; }

		public bool GenerateDataObjects { get; set; }

		public bool GenerateAdapters { get; set; }

		public bool AddAutoGeneratedHeader { get; set; }

		public bool AdjustColumnTypes { get; set; }

		private Regex _includeTableMatcher;

		public SqlServerModelGenerator()
		{
			IncludeTables = null;
			BaseDataContextClass = "DbManager";
			DatabaseName = null;
			DataContextName = null;
			DataNamespace = null;
			PocoNamespace = null;
			BaseEntityClass = null;
			OneToManyDataObjectAssociationType = "IEnumerable<{0}>";
			OneToManyPocoAssociationType = "List<{0}>";
			RenderForeignKeys = false;
			RenderBackReferences = true;
			RenderField = false;
			DatabaseQuote = null;
			OwnerToInclude = null;
			GenerateDataContextClass = true;
			AddAutoGeneratedHeader = false;
			DataObjectSuffix = "Data";
			PocoSuffix = "";
			AdapterSuffix = "Adapter";
			AdjustColumnTypes = true;

			SingularizeDataContextPropertyNames = false;
			PluralizeDataContextPropertyNames = true;
			SingularizeClassNames = true;
			PluralizeClassNames = false;

			AppDomain.CurrentDomain.AssemblyResolve += (_, args) =>
			{
				foreach (var a in _assemblies)
				{
					if (args.Name.ToLower().IndexOf(a.Key.ToLower()) >= 0)
					{
						return Assembly.LoadFile(a.Value);
					}
				}

				if (_dataProviderAssembly != null &&
					args.Name.Split(',')[0] == Path.GetFileNameWithoutExtension(_dataProviderAssembly))
				{
					return Assembly.LoadFile(_dataProviderAssembly);
				}

				return null;
			};
		}


		private static readonly Dictionary<string, string> _assemblies = new Dictionary<string, string>();

		public virtual void WriteComment(string s)
		{
			WriteLine("//{0}", s);
		}

		public virtual void WriteSummary(string s)
		{
			if (!string.IsNullOrWhiteSpace(s))
			{
				WriteLine("/// <summary>");
				WriteLine("/// {0}", s);
				WriteLine("/// </summary>");
			}
		}

		public virtual void WriteUsing(string s)
		{
			WriteLine("using {0};", s);
		}

		public virtual void WriteBeginNamespace(string s)
		{
			WriteLine("namespace {0}", s);
			WriteLine("{");
			PushIndent("\t");
		}

		public virtual void WriteEndNamespace()
		{
			PopIndent();
			WriteLine("}");
		}

		public virtual void WriteBeginClass(string className)
		{
			WriteBeginClass(className, null);
		}

		public virtual void WriteBeginClass(string className, string baseClassName)
		{
			Write("public {0}class {1}",
				GeneratePartialClasses ? "partial " : "",
				className);

			if (!string.IsNullOrEmpty(baseClassName))
			{
				Write(" : {0}", baseClassName);
			}
			WriteLine("");
			WriteLine("{");
			PushIndent("\t");
		}

		public virtual void WriteEndClass()
		{
			PopIndent();
			WriteLine("}");
		}

		protected virtual void WriteTableProperty(string name, string pname, string desc)
		{
			WriteTableProperty(name, pname, 0, 0, desc);
		}

		protected virtual void WriteTableProperty(string name, string pname, int maxlen, int maxplen, string desc)
		{
			WriteSummary(desc);
			WriteLine("public Table<{0}> {1} {{ get {{ return this.GetTable<{0}>();}} }}", RemoveSuffix(name, "_t"),
				RemoveSuffix(pname, "_t"));
		}

		public virtual void WriteAttribute(string a)
		{
			Write("[{0}]", a);
		}

		public virtual void WriteAttributeLine()
		{
			WriteLine("");
		}

		private string _connectionType;
		private string _dataProviderAssembly = null;

		private bool _isMetadataLoaded;

		private string RemoveSuffix(string value, string suffix)
		{
			if (value.EndsWith(suffix.ToLowerInvariant()) ||
				value.EndsWith(suffix.ToUpperInvariant()))
			{
				value = value.Substring(0, value.Length - suffix.Length);
			}

			return value;
		}

		public virtual void RenderColumn(CodeColumn column, string[] attrs, CodeType codeType)
		{
			WriteSummary(column.Description);

			if (codeType == CodeType.DataObject)
			{
				if (attrs.Any(_ => _ != null))
				{
					for (var i = 0; i < attrs.Length; i++)
					{
						if (attrs[i] != null)
						{
							Write("[");
							Write(attrs[i]);
							Write("]");
							WriteLine("");
						}
					}
				}
				else
				{
					WriteSpace(1);
				}
			}

			Write("public {0} {1}", column.Type, column.MemberName);

			if (RenderField)
			{
				Write(";");
			}
			else
			{
				Write(" { get; set; }");
			}

			WriteLine("");
			WriteLine("");
		}

		public virtual void RenderForeignKey(CodeForeignKey key, CodeType codeType)
		{
			if (!RenderForeignKeys)
			{
				return;
			}

			if (codeType == CodeType.DataObject)
			{
				WriteComment(" " + key.KeyName);
				WriteLine("[Association(ThisKey=\"{0}\", OtherKey=\"{1}\", CanBeNull={2})]",
					string.Join(", ", (from c in key.ThisColumns select c.ColumnName).ToArray()),
					string.Join(", ", (from c in key.OtherColumns select c.MemberName).ToArray()),
					key.CanBeNull ? "true" : "false");

				if (key.Attributes.Count > 0)
				{
					WriteAttribute(string.Join(", ", key.Attributes.Distinct().ToArray()));
					WriteAttributeLine();
				}
			}

			Write("public ");

			var otherTableName = RemoveSuffix(key.OtherTable.DataObjectClassName, "_t");

			if (key.AssociationType == CodeAssociationType.OneToMany)
			{
				Write(codeType == CodeType.DataObject
					? OneToManyDataObjectAssociationType
					: OneToManyPocoAssociationType, otherTableName);
			}
			else
			{
				Write(otherTableName);
			}

			Write(" ");
			Write(otherTableName);
			if (key.AssociationType == CodeAssociationType.OneToMany)
			{
				if (otherTableName.EndsWith("s"))
				{
					Write("es");
				}
				else
				{
					Write("s");
				}
			}
			else if (key.OtherTable.DataObjectClassName == otherTableName)
			{
				Write("Other");
			}

			if (RenderField)
			{
				WriteLine(";");
			}
			else
			{
				WriteLine(" { get; set; }");
			}
		}

		class MemberDefinition
		{
			public string Name { get; set; }
			public string Type { get; set; }
			public string OriginalColumnName { get; set; }
			public string Comment { get; set; }
			public bool Skip { get; set; }
			public bool IsContainer { get; set; }
			public string ElementTypeName { get; set; }
		}

		class ClassDefinition
		{
			public string Name { get; set; }
			public string AdapterName { get; set; }
			public List<MemberDefinition> Members { get; private set; }
			public string OriginalTableName { get; set; }

			public ClassDefinition()
			{
				Members = new List<MemberDefinition>();
			}
		}

		private string GetFkName(CodeForeignKey key)
		{
			var isBackReference = key.KeyName.Contains("BackReference");
			var keyName = key.KeyName.Replace("FK_", "").Replace("_T", "").Replace("_BackReference", "");

			var parts = keyName.Split('_');
			if (parts.Length == 1)
			{
				return key.KeyName;
			}

			if (isBackReference)
			{
				return parts[0];
			}

			return parts[1];
		}

		private void BuildPocoModel()
		{
			var tableClassMap = new Dictionary<CodeTable, ClassDefinition>();

			foreach (var table in _tableList)
			{
				var defn = BuildClass(table);
				tableClassMap.Add(table, defn);
			}

			if (RenderForeignKeys)
			{
				foreach (var table in _tableList)
				{
					if (table.ForeignKeys.Count == 0)
					{
						continue;
					}

					var defn = tableClassMap[table];

					foreach (var key in table.ForeignKeys.Values)
					{
						var myColumn = key.ThisColumns.FirstOrDefault();
						if (myColumn == null)
						{
							continue;
						}

						var mbr = new MemberDefinition
						{
							OriginalColumnName = GetFkName(key)
						};

						var ombr = defn.Members.FirstOrDefault(m => m.OriginalColumnName == myColumn.MemberName);
						if (ombr != null)
						{
							ombr.Skip = true;
						}

						defn.Members.Add(mbr);
						var mbrType = RemoveSuffix(key.OtherTable.DataObjectClassName, "_t");
						if (key.AssociationType == CodeAssociationType.OneToMany ||
							key.AssociationType == CodeAssociationType.Auto)
						{
							mbr.Name = PluralizeAssociationName(RemoveSuffix(mbr.OriginalColumnName, "_ID"));
							mbr.Type = OneToManyPocoAssociationType.FormatWith(mbrType);
							mbr.IsContainer = true;
							mbr.ElementTypeName = mbrType;
						}
						else
						{
							mbr.Name = SingularizeAssociationName(RemoveSuffix(mbr.OriginalColumnName, "_ID"));
							mbr.Type = mbrType;
						}

						mbr.Comment = key.AssociationType.ToString();
						var isBackReference = key.KeyName.Contains("BackReference");
						if (isBackReference)
						{
							mbr.Comment += ", backref";
						}

						if (mbr.Name.IsNullOrEmpty())
						{
							mbr.Name = "NO_NAME";
							mbr.Comment += ", '" + key.KeyName + "'";
						}
					}
				}
			}

			foreach (var defn in tableClassMap.Values)
			{
				if (GeneratePocos)
				{
					GeneratePocoModel(defn);
				}
				
				if (GenerateAdapters)
				{
					GenerateAdapter(defn);
				}
			}
		}

		private void GeneratePocoModel(ClassDefinition defn)
		{
			GenerationEnvironment.Clear();

			Console.WriteLine("Generating POCO " + defn.Name);

			WriteAutoGeneratedHeader();

			RenderUsings(_pocoUsings);

			WriteBeginNamespace(PocoNamespace);

			WriteAttribute("Serializable");
			WriteAttributeLine();
			WriteBeginClass(defn.Name + (PocoSuffix ?? ""));

			foreach (var member in defn.Members)
			{
				if (member.Skip)
				{
					continue;
				}
				if (!member.Comment.IsNullOrEmpty())
				{
					WriteComment(member.Comment);
				}
				WriteLine("{2}public {0} {1} {{ get; set; }}", 
					member.Type, 
					member.Name.IsNullOrEmpty() ? "NO_NAME" : member.Name,
					member.Skip ? "// " : "");
				WriteLine("");
			}

			WriteEndClass();
			WriteEndNamespace();

			var model = new Code
			{
				Type = CodeType.Poco,
				Name = defn.Name,
				Content = GenerationEnvironment.ToString()
			};

			_results.Models.Add(model);

			GenerationEnvironment.Clear();
		}

		private void GenerateAdapter(ClassDefinition defn)
		{
			GenerationEnvironment.Clear();

			WriteAutoGeneratedHeader();

			RenderUsings(_adapterUsings);

			WriteBeginNamespace(AdapterNamespace);

			WriteBeginClass(defn.AdapterName);

			GenerateFromAdapter(defn);
			WriteLine("");
			GenerateToAdapter(defn);

			WriteEndClass();
			WriteEndNamespace();

			var model = new Code
			{
				Type = CodeType.Adapter,
				Name = defn.AdapterName,
				Content = GenerationEnvironment.ToString()
			};

			_results.Models.Add(model);

			GenerationEnvironment.Clear();
		}

		private void GenerateFromAdapter(ClassDefinition defn)
		{
			WriteLine("public static {0}{1} From{0}{2}(this {0}{2} source)", defn.Name, DataObjectSuffix, PocoSuffix);
			WriteLine("{");
			PushIndent();

			WriteLine("if (source == null)");
			WriteLine("{");
			PushIndent();
			WriteLine("return null;");
			PopIndent();
			WriteLine("}");

			WriteLine("var result = new {0}{1}", defn.Name, DataObjectSuffix);
			WriteLine("{");
			PushIndent();


			foreach (var member in defn.Members)
			{
				if (member.Skip ||
					member.Name.IsNullOrEmpty())
				{
					continue;
				}

				if (member.IsContainer)
				{
					WriteLine("{0} = source.{0}.From{1}(),", member.Name, member.ElementTypeName);
				}
				else
				{
					WriteLine("{0} = source.{0},", member.Name);
				}
			}

			PopIndent();
			WriteLine("};");
			WriteLine("");
			WriteLine("return result;");
			PopIndent();
			WriteLine("}");

			WriteLine("");
			WriteLine("private static readonly {0}{1}[] _empty{0}{1}Objects = new {0}{1}[0];", defn.Name, DataObjectSuffix);
			WriteLine("public static IEnumerable<{0}{1}> From{0}{2}(this IEnumerable<{0}{2}> source)", defn.Name, DataObjectSuffix, PocoSuffix);
			WriteLine("{");
			PushIndent();

			WriteLine("if (source == null)");
			WriteLine("{");
			PushIndent();
			WriteLine("return _empty{0}{1}Objects;", defn.Name, DataObjectSuffix);
			PopIndent();
			WriteLine("}");

			WriteLine("");

			WriteLine("var result = source.Select(From{0}{1});", defn.Name, DataObjectSuffix);
			WriteLine("return result;");
			PopIndent();
			WriteLine("}");

			WriteLine("");
		}

		private void GenerateToAdapter(ClassDefinition defn)
		{
			Console.WriteLine("Generating adapter " + defn.AdapterName);

			WriteLine("public static {0}{1} To{0}{1}(this {0}{2} source)", defn.Name, PocoSuffix, DataObjectSuffix);
			WriteLine("{");
			PushIndent();

			WriteLine("if (source == null)");
			WriteLine("{");
			PushIndent();
			WriteLine("return null;");
			PopIndent();
			WriteLine("}");

			WriteLine("var result = new {0}{1}", defn.Name, PocoSuffix);
			WriteLine("{");
			PushIndent();


			foreach (var member in defn.Members)
			{
				if (member.Skip ||
					member.Name.IsNullOrEmpty())
				{
					continue;
				}

				WriteLine("{0} = source.{0},", member.Name);
			}

			PopIndent();
			WriteLine("};");
			WriteLine("");
			WriteLine("return result;");
			PopIndent();
			WriteLine("}");

			WriteLine("");
			WriteLine("private static readonly {0}{1}[] _empty{0}{1}Pocos = new {0}{1}[0];", defn.Name, PocoSuffix);
			WriteLine("public static IEnumerable<{0}{1}> To{0}{1}(this IEnumerable<{0}{2}> source)", defn.Name, PocoSuffix, DataObjectSuffix);
			WriteLine("{");
			PushIndent();

			WriteLine("if (source == null)");
			WriteLine("{");
			PushIndent();
			WriteLine("return _empty{0}{1}Pocos;", defn.Name, PocoSuffix);
			PopIndent();
			WriteLine("}");

			WriteLine("");

			WriteLine("var result = source.Select(To{0}{1});", defn.Name, PocoSuffix);
			WriteLine("return result;");
			PopIndent();
			WriteLine("}");

			WriteLine("");
		}

		private ClassDefinition BuildClass(CodeTable table)
		{
			var defn = new ClassDefinition
			{
				Name = table.PocoClassName,
				//Name = RemoveSuffix(table.DataObjectClassName, "_t"),
				OriginalTableName = table.TableName,
				AdapterName = table.TableName.Replace("_", "") + (AdapterSuffix ?? "")
			};

			foreach (var column in table.Columns.Values)
			{
				var memberName = column.MemberName;
				if (AdjustColumnTypes)
				{
					if (column.MemberName.EndsWith("_ID"))
					{
						memberName = RemoveSuffix(column.MemberName, "_ID") + "Id";
					}
					else
					{
						memberName = Regex.Replace(column.MemberName, "^F[0-9]+_", "");
						memberName = RemoveSuffix(memberName, "_VC");
						memberName = RemoveSuffix(memberName, "_BT");
						memberName = RemoveSuffix(memberName, "_DT");
						memberName = RemoveSuffix(memberName, "_IN");
						memberName = RemoveSuffix(memberName, "_TX");
						memberName = RemoveSuffix(memberName, "_DC");
						memberName = RemoveSuffix(memberName, "_SM");
						memberName = RemoveSuffix(memberName, "_TI");
						memberName = RemoveSuffix(memberName, "_CH");
						memberName = RemoveSuffix(memberName, "_BI");
						memberName = RemoveSuffix(memberName, "_MX");
						memberName = RemoveSuffix(memberName, "_PC");
					}

					memberName = memberName.Replace("_", "");
				}

				var member = new MemberDefinition
				{
					Name = memberName,
					Type = GetColumnType(memberName, column),
					OriginalColumnName = column.MemberName,
					Skip = column.IsIdentity
				};

				defn.Members.Add(member);
			}

			return defn;
		}

		private readonly Regex _amountMatcher = new Regex(@"Amount\d*\b", RegexOptions.Compiled | RegexOptions.IgnoreCase);
		private readonly Regex _dateMatcher = new Regex(@"(\bDate)|(Date\d*\b)", RegexOptions.Compiled | RegexOptions.IgnoreCase);

		private string GetColumnType(string columnName, CodeColumn col)
		{
			if (!AdjustColumnTypes)
			{
				return col.Type;
			}

			if (col.Type == "byte")
			{
				return "int";
			}

			if (col.Type == "short")
			{
				return "int";
			}

			var isAmount = _amountMatcher.IsMatch(columnName);
			if (isAmount && col.Type == "string")
			{
				if (col.IsNullable)
				{
					return "decimal?";
				}

				return "decimal?";
			}

			var isDate = _dateMatcher.IsMatch(columnName);
			if (isDate && col.Type == "string")
			{
				if (col.IsNullable)
				{
					return "DateTime?";
				}

				return "DateTime?";
			}

			return col.Type;
		}

		public virtual void RenderTable(CodeTable table, bool renderForeignKeys, CodeType codeType)
		{
			WriteSummary(table.Description);

			if (codeType == CodeType.DataObject && 
				table.IsView)
			{
				WriteComment(" View");
			}

			RenderTableAttributes(table);

			table.DataObjectClassName = RemoveSuffix(table.DataObjectClassName, "_t");

			Console.WriteLine("Generating data object " + table.DataObjectClassName);

			WriteBeginClass(table.DataObjectClassName, table.BaseClassName);

			if (AdjustColumnTypes &&
				!table.ColumnsCleaned)
			{
				table.ColumnsCleaned = true;

				foreach (var column in table.Columns.Values)
				{
					column.MemberName = Regex.Replace(column.MemberName, "^F[0-9]+_", "");
					column.MemberName = RemoveSuffix(column.MemberName, "_VC");
					column.MemberName = RemoveSuffix(column.MemberName, "_BT");
					column.MemberName = RemoveSuffix(column.MemberName, "_DT");
					column.MemberName = RemoveSuffix(column.MemberName, "_IN");
					column.MemberName = RemoveSuffix(column.MemberName, "_TX");
					column.MemberName = RemoveSuffix(column.MemberName, "_DC");
					column.MemberName = RemoveSuffix(column.MemberName, "_SM");
					column.MemberName = RemoveSuffix(column.MemberName, "_TI");
					column.MemberName = RemoveSuffix(column.MemberName, "_CH");
					column.MemberName = RemoveSuffix(column.MemberName, "_BI");
					column.MemberName = RemoveSuffix(column.MemberName, "_MX");

					if (column.MemberName.EndsWith("_ID"))
					{
						column.MemberName = RemoveSuffix(column.MemberName, "_ID") + "Id";
					}

					column.MemberName = column.MemberName.Replace("_", "");
				}
			}

			if (table.Columns.Count > 0)
			{
				foreach (var c in from c in table.Columns.Values orderby c.ID select c)
				{
					var attrs = new[]
					{
						c.IsNullable ? "Nullable" : c.IsIdentity ? "Identity" : null,
						c.IsIdentity && c.IsNullable ? "Identity" : null,
						c.IsPrimaryKey ? string.Format("PrimaryKey({0})", c.PKIndex) : null,
						c.Attributes.Count == 0 ? null : string.Join(", ", c.Attributes.Distinct().ToArray()),
						string.Format("MapField(\"{0}\")", c.ColumnName),
					};

					RenderColumn(c, attrs, codeType);
				}
			}

			if (RenderForeignKeys && table.ForeignKeys.Count > 0)
			{
				foreach (var key in table.ForeignKeys.Values)
				{
					WriteLine("");
					RenderForeignKey(key, codeType);
				}
			}

			WriteEndClass();
		}

		public virtual void RenderTableAttributes(CodeTable t)
		{
			if (t.Attributes.Count > 0)
			{
				WriteAttribute(string.Join(", ", t.Attributes.Distinct().ToArray()));
				WriteAttributeLine();
			}

			var tbl = "TableName(";

			if (!string.IsNullOrEmpty(DatabaseName))
			{
				tbl += string.Format("Database=\"{0}\", ", DatabaseName);
			}

			if (!string.IsNullOrEmpty(t.Owner))
			{
				tbl += string.Format("Owner=\"{0}\", ", t.Owner);
			}

			tbl += string.Format("Name=\"{0}\")", t.TableName);

			WriteAttribute(tbl);
			WriteAttributeLine();
		}

		private readonly List<string> _dataUsings = new List<string>
		{
			"System",
			"BLToolkit.Data",
			"BLToolkit.Data.Linq",
			"BLToolkit.DataAccess",
			"BLToolkit.Mapping",
			"BLToolkit.Data.DataProvider",
			"BLToolkit.Data.Sql",
			"BLToolkit.Data.Sql.SqlProvider"
		};

		private readonly List<string> _pocoUsings = new List<string>
		{
			"System",
		};


		private readonly List<string> _adapterUsings = new List<string>
		{
			"System",
			"System.Collections.Generic"
		};

		public virtual void RenderUsings(List<string> usings)
		{
			var q =
				from ns in usings.Distinct()
				group ns by ns.Split('.')[0];

			var groups =
				(from ns in q where ns.Key == "System" select ns).Concat
					(from ns in q where ns.Key != "System" orderby ns.Key select ns);

			foreach (var gr in groups)
			{
				foreach (var ns in from s in gr orderby s select s)
				{
					WriteUsing(ns);
				}

				WriteLine("");
			}
		}

		public virtual void BeforeGenerateModel()
		{
			
		}

		public virtual void BeforeGenerateDataModel()
		{
			_dataUsings.Add("System.Runtime.Serialization");

			foreach (var t in _tables.Values)
			{
				t.Attributes.AddRange(new[]
						{
							"Serializable",
						});
			}

			_dataUsings.Add("BLToolkit.Validation");

			foreach (var t in _tables.Values)
			{
				foreach (var c in t.Columns.Values)
				{
					if (c.Type == "string" && c.Length > 0)
					{
						c.Attributes.Add(string.Format("MaxLength({0})", c.Length));
					}

					if (!c.IsNullable)
					{
						c.Attributes.Add("Required");
					}
				}
			}
		}

		public virtual void BeforeGenerateDataContext()
		{
			
		}

		public virtual void AfterGenerateDataContext()
		{
			
		}

		public virtual void AfterGenerateDataModel()
		{
		}

		public virtual void AfterGenerateModel()
		{			
		}

		public virtual void BeforeWriteTableProperty()
		{			
		}

		public virtual void AfterWriteTableProperty()
		{			
		}

		private Results _results;

		private List<CodeTable> _tableList;

		public override Results GenerateDataModel()
		{
			if (AdapterNamespace.IsNullOrEmpty())
			{
				AdapterNamespace = DataNamespace;
			}

			_connectionType = typeof(SqlConnection).AssemblyQualifiedName;

			if (ConnectionString != null)
			{
				ConnectionString = ConnectionString.Trim();
			}

			if (DataContextName != null)
			{
				DataContextName = DataContextName.Trim();
			}

			if (string.IsNullOrEmpty(ConnectionString))
			{
				if (DatabaseServer.IsNullOrEmpty() ||
					DatabaseName.IsNullOrEmpty())
				{
					Error("ConnectionString cannot be empty.");
					return null;
				}

				if (DatabaseUsername.NotNullOrEmpty() &&
					DatabasePassword.NotNullOrEmpty())
				{
					ConnectionString =
						@"data source={0};initial catalog={1};persist security info=True;user id={2};password={3};MultipleActiveResultSets=True;"
							.FormatWith(DatabaseServer, DatabaseName, DatabaseUsername, DatabasePassword);
				}
				else
				{
					ConnectionString =
						@"data source={0};initial catalog={1};persist security info=True;Integrated Security=True;MultipleActiveResultSets=True;"
							.FormatWith(DatabaseServer, DatabaseName);
				}
			}

			_results = new Results();

			if (string.IsNullOrEmpty(DataContextName))
			{
				DataContextName = "DataContext";
			}

			LoadMetadata();

			var allTables = (from t in _tables.Values orderby t.TableName select t).ToList();
			
			if (IncludeTables != null &&
				IncludeTables.Count > 0)
			{
				_tableList = allTables.Where(t => IncludeTables.Contains(t.TableName)).ToList();
			}
			
			if (!IncludeTablePattern.IsNullOrEmpty())
			{
				if (_tableList == null)
				{
					_tableList = new List<CodeTable>();
				}

				_includeTableMatcher = new Regex(IncludeTablePattern,
					RegexOptions.Compiled | RegexOptions.CultureInvariant | RegexOptions.IgnoreCase);

				foreach (var table in allTables)
				{
					if (_includeTableMatcher.IsMatch(table.TableName) &&
						!_tableList.Contains(table))
					{
						_tableList.Add(table);
					}
				}
			}

			if (_tableList == null)
			{
				_tableList = allTables;
			}

			if (GeneratePocos || GenerateAdapters)
			{
				BuildPocoModel();
			}
			
			if (GenerateDataObjects)
			{
				GenerateDataObjectModels();
			}

			return _results;
		}

		protected virtual void WriteAutoGeneratedHeader()
		{
			if (!AddAutoGeneratedHeader)
			{
				return;
			}

			WriteComment("---------------------------------------------------------------------------------------------------");
			WriteComment(" <auto-generated>");
			WriteComment("    This code was auto generated.");
			WriteComment("    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.");
			WriteComment(" </auto-generated>");
			WriteComment("---------------------------------------------------------------------------------------------------");
		}

		protected virtual void GenerateDataContext()
		{
			if (GeneratePocos)
			{
				return;
			}

			GenerationEnvironment.Clear();

			BeforeGenerateDataContext();
	
			WriteAutoGeneratedHeader();
			RenderUsings(_dataUsings);
			WriteBeginNamespace(DataNamespace);
			WriteBeginClass(DataContextName);

			BeforeWriteTableProperty();

			foreach (var t in _tableList)
			{
				WriteTableProperty(t.DataObjectClassName, t.DataContextPropertyName ?? t.DataObjectClassName, t.Description);
			}

			AfterWriteTableProperty();

			PopIndent();

			WriteEndClass();
			WriteEndNamespace();

			AfterGenerateDataContext();

			_results.DataContext = GenerationEnvironment.ToString();
			GenerationEnvironment.Clear();
		}

		private void GenerateTableModel(CodeTable table)
		{
			GenerationEnvironment.Clear();
			BeforeGenerateModel();

			WriteAutoGeneratedHeader();

			RenderUsings(_dataUsings);

			WriteBeginNamespace(DataNamespace);

			RenderTable(table, RenderForeignKeys, CodeType.DataObject);

			WriteEndNamespace();

			AfterGenerateDataModel();

			var model = new Code
			{
				Type = CodeType.DataObject,
				Name = table.DataObjectClassName,
				Content = GenerationEnvironment.ToString()
			};

			_results.Models.Add(model);

			GenerationEnvironment.Clear();
		}

		private void GenerateDataObjectModels()
		{
			BeforeGenerateDataModel();

			GenerateDataContext();

			foreach (var table in _tableList)
			{
				GenerateTableModel(table);
			}

			AfterGenerateDataModel();
		}

		private void WriteSpace(int len)
		{
			while (len-- > 0)
			{
				Write(" ");
			}
		}

		private List<T> CreateList<T>(T item)
		{
			return new List<T>();
		}

		public virtual IDbConnection GetConnectionObject()
		{
			Type connType = null;

			if (_dataProviderAssembly != null)
			{
				try
				{
					var assembly = Assembly.LoadFile(_dataProviderAssembly);
					connType = assembly.GetType(_connectionType)
								?? assembly.GetType(_connectionType.Substring(0, _connectionType.IndexOf(",")));
				}
				catch
				{
				}
			}

			if (connType == null)
			{
				connType = Type.GetType(_connectionType);
			}

			return (IDbConnection) Activator.CreateInstance(connType);
		}

		private IDbConnection GetConnection()
		{
			var conn = GetConnectionObject();

			conn.ConnectionString = ConnectionString;
			conn.Open();

			return conn;
		}

		private void LoadMetadata()
		{
			if (_isMetadataLoaded)
			{
				return;
			}

			_isMetadataLoaded = true;

			if (!string.IsNullOrEmpty(_dataProviderAssembly) && !_dataProviderAssembly.Contains(":") &&
				_dataProviderAssembly.Contains(".."))
			{
				try
				{
					string path = ProcessHelpers.HostProcessDirectory;
					_dataProviderAssembly = Path.GetFullPath(Path.Combine(path, _dataProviderAssembly));
				}
				catch
				{
				}
			}

			BeforeLoadMetadata();
			LoadServerMetadata();

			if (DatabaseQuote != null)
			{
				foreach (var t in _tables.Values)
				{
					t.TableName = string.Format("{1}{0}{2}", t.TableName, DatabaseQuote.FirstOrDefault(),
						DatabaseQuote.Skip(1).FirstOrDefault() ?? DatabaseQuote.FirstOrDefault());
					foreach (var c in t.Columns.Values)
					{
						c.ColumnName = string.Format("{1}{0}{2}", c.ColumnName, DatabaseQuote.FirstOrDefault(),
							DatabaseQuote.Skip(1).FirstOrDefault() ?? DatabaseQuote.FirstOrDefault());
					}
				}
			}

			foreach (var t in _tables.Values)
			{
				if (t.DataObjectClassName.Contains(" "))
				{
					var ss = t.DataObjectClassName.Split(' ').Where(_ => _.Trim().Length > 0).Select(_ => char.ToUpper(_[0]) + _.Substring(1));
					t.DataObjectClassName = string.Join("", ss.ToArray());
				}
			}

			foreach (var t in _tables.Values)
			{
				foreach (var key in t.ForeignKeys.Values.ToList())
				{
					if (!key.KeyName.EndsWith("_BackReference"))
					{
						key.OtherTable.ForeignKeys.Add(key.KeyName + "_BackReference", key.BackReference = new CodeForeignKey
						{
							KeyName = key.KeyName + "_BackReference",
							MemberName = key.MemberName + "_BackReference",
							AssociationType = CodeAssociationType.Auto,
							OtherTable = t,
							ThisColumns = key.OtherColumns,
							OtherColumns = key.ThisColumns,
						});
					}
				}
			}

			foreach (var t in _tables.Values)
			{
				foreach (var key in t.ForeignKeys.Values)
				{
					if (key.BackReference != null && key.AssociationType == CodeAssociationType.Auto)
					{
						if (key.ThisColumns.All(_ => _.IsPrimaryKey))
						{
							if (t.Columns.Values.Count(_ => _.IsPrimaryKey) == key.ThisColumns.Count)
							{
								key.AssociationType = CodeAssociationType.OneToOne;
							}
							else
							{
								key.AssociationType = CodeAssociationType.ManyToOne;
							}
						}
						else
						{
							key.AssociationType = CodeAssociationType.ManyToOne;
						}

						key.CanBeNull = key.ThisColumns.All(_ => _.IsNullable);
					}
				}
			}

			if (_tables.Values.SelectMany(_ => _.ForeignKeys.Values).Any(_ => _.AssociationType == CodeAssociationType.OneToMany))
			{
				_dataUsings.Add("System.Collections.Generic");
				_pocoUsings.Add("System.Collections.Generic");
			}

			var keyWords = new HashSet<string>
			{
				"abstract",
				"as",
				"base",
				"bool",
				"break",
				"byte",
				"case",
				"catch",
				"char",
				"checked",
				"class",
				"const",
				"continue",
				"decimal",
				"default",
				"delegate",
				"do",
				"double",
				"else",
				"enum",
				"event",
				"explicit",
				"extern",
				"false",
				"finally",
				"fixed",
				"float",
				"for",
				"foreach",
				"goto",
				"if",
				"implicit",
				"in",
				"int",
				"interface",
				"internal",
				"is",
				"lock",
				"long",
				"new",
				"null",
				"object",
				"operator",
				"out",
				"override",
				"params",
				"private",
				"protected",
				"public",
				"readonly",
				"ref",
				"return",
				"sbyte",
				"sealed",
				"short",
				"sizeof",
				"stackalloc",
				"static",
				"struct",
				"switch",
				"this",
				"throw",
				"true",
				"try",
				"typeof",
				"uint",
				"ulong",
				"unchecked",
				"unsafe",
				"ushort",
				"using",
				"virtual",
				"volatile",
				"void",
				"while"
			};

			foreach (var t in _tables.Values)
			{
				if (keyWords.Contains(t.DataObjectClassName))
				{
					t.DataObjectClassName = "@" + t.DataObjectClassName;
				}

				if (keyWords.Contains(t.DataContextPropertyName))
				{
					t.DataContextPropertyName = "@" + t.DataContextPropertyName;
				}

				foreach (var col in t.Columns.Values)
				{
					if (keyWords.Contains(col.MemberName))
					{
						col.MemberName = "@" + col.MemberName;
					}
				}
			}


			AfterLoadMetadata();
		}

		public virtual string PluralizeAssociationName(string assoc)
		{
			return ToPlural(assoc);
			//return assoc + "s";
		}

		public virtual string SingularizeAssociationName(string assoc)
		{
			return ToSingular(assoc);
			//return assoc;
		}

		public virtual void BeforeLoadMetadata()
		{			
		}

		public virtual void AfterLoadMetadata()
		{
			foreach (var t in _tables.Values)
			{
				var className = RemoveSuffix(t.DataObjectClassName ?? t.TableName, "_t");
				if (PluralizeDataContextPropertyNames || SingularizeDataContextPropertyNames)
				{
					var propName = t.DataContextPropertyName ?? className;
					var newName = PluralizeDataContextPropertyNames ? ToPlural(propName) : ToSingular(propName);

					t.DataContextPropertyName = newName;
				}

				if (PluralizeClassNames || SingularizeClassNames)
				{
					className = PluralizeClassNames ? ToPlural(className) : ToSingular(className);
				}

				t.DataObjectClassName = className;
				if (DataObjectSuffix != null)
				{
					t.DataObjectClassName += DataObjectSuffix;
				}

				className = RemoveSuffix(t.PocoClassName ?? t.TableName, "_t");

				t.PocoClassName = className;
				if (!PocoSuffix.IsNullOrEmpty())
				{
					t.PocoClassName += PocoSuffix;
				}
			}
		}

		private readonly Dictionary<string, CodeTable> _tables = new Dictionary<string, CodeTable>();

		private void LoadServerMetadata()
		{
			var tables = CreateList(new {ID = "", Table = new CodeTable()});
			var columns = CreateList(new {ID = "", Column = new CodeColumn()});

			using (var conn = GetConnection())
			{
				using (var cmd = conn.CreateCommand())
				{
					// Load tables & views.
					//
					var s = @"
			SELECT
				TABLE_CATALOG + '.' + TABLE_SCHEMA + '.' + TABLE_NAME AS TABLE_FULLNAME,
				TABLE_SCHEMA,
				TABLE_NAME,
				TABLE_TYPE,
				ISNULL(CONVERT(varchar(8000), x.Value), '') AS TABLE_DESC
			FROM
				INFORMATION_SCHEMA.TABLES s
				LEFT JOIN 
					sys.tables t 
				ON 
					OBJECT_ID(TABLE_CATALOG + '.' + TABLE_SCHEMA + '.' + TABLE_NAME) = t.object_id
				LEFT JOIN 
					sys.extended_properties x 
				ON 
					OBJECT_ID(TABLE_CATALOG + '.' + TABLE_SCHEMA + '.' + TABLE_NAME) = x.major_id AND 
					x.minor_id = 0 AND 
					x.name = 'MS_Description'
			WHERE {0}
			(
				t.object_id IS NULL OR
				t.is_ms_shipped <> 1 AND
				(
					SELECT 
						major_id 
					FROM 
						sys.extended_properties 
					WHERE
						major_id = t.object_id and 
						minor_id = 0           and 
						class    = 1           and 
						name     = N'microsoft_database_tools_support'
					) IS NULL
			)";

					if (string.IsNullOrWhiteSpace(OwnerToInclude))
					{
						cmd.CommandText = string.Format(s, "");
					}
					else
					{
						cmd.CommandText = string.Format(s, " TABLE_SCHEMA = '" + OwnerToInclude + "' AND ");
					}

					using (var rd = cmd.ExecuteReader())
					{
						while (rd.Read())
						{
							var t = new
							{
								ID = Convert.ToString(rd[0]),
								Table = new CodeTable
								{
									Owner = rd[1].ToString(),
									TableName = rd[2].ToString(),
									DataObjectClassName = rd[2].ToString(),
									IsView = rd[3].ToString() == "VIEW",
									BaseClassName = BaseEntityClass,
									Description = Convert.ToString(rd[4]),
								}
							};

							tables.Add(t);
						}
					}

					// Load columns.
					//
					s = @"
			SELECT
				(TABLE_CATALOG + '.' + TABLE_SCHEMA + '.' + TABLE_NAME) as id,
				(CASE WHEN IS_NULLABLE = 'YES' THEN 1 ELSE 0 END)         as isNullable,
				ORDINAL_POSITION         as colid,
				COLUMN_NAME              as name,
				c.DATA_TYPE              as dataType,
				CHARACTER_MAXIMUM_LENGTH as length, 
				ISNULL(NUMERIC_PRECISION, DATETIME_PRECISION) AS prec,
				NUMERIC_SCALE            as scale,
				COLUMNPROPERTY(object_id('[' + TABLE_SCHEMA + '].[' + TABLE_NAME + ']'), COLUMN_NAME, 'IsIdentity') as isIdentity,
				ISNULL(CONVERT(varchar(8000), x.Value), '') AS COLUMN_DESC
			FROM
				INFORMATION_SCHEMA.COLUMNS c
			  LEFT JOIN 
				sys.extended_properties x 
			  ON 
				OBJECT_ID(TABLE_CATALOG + '.' + TABLE_SCHEMA + '.' + TABLE_NAME) = x.major_id AND 
				ORDINAL_POSITION = x.minor_id AND 
				x.name = 'MS_Description'
			{0}";

					if (string.IsNullOrWhiteSpace(OwnerToInclude))
					{
						cmd.CommandText = string.Format(s, "");
					}
					else
					{
						cmd.CommandText = string.Format(s, "WHERE TABLE_SCHEMA = '" + OwnerToInclude + "' ");
					}

					using (var rd = cmd.ExecuteReader())
					{
						while (rd.Read())
						{
							var col = new
							{
								ID = Convert.ToString(rd["id"]),
								Column = new CodeColumn
								{
									ID = Convert.ToInt16(rd["colid"]),
									ColumnName = Convert.ToString(rd["name"]),
									MemberName = Convert.ToString(rd["name"]),
									ColumnType = Convert.ToString(rd["dataType"]),
									IsNullable = Convert.ToBoolean(rd["isNullable"]),
									IsIdentity = Convert.ToBoolean(rd["isIdentity"]),
									Length = rd.IsDBNull(rd.GetOrdinal("length")) ? 0 : Convert.ToInt64(rd["length"]),
									Precision = rd.IsDBNull(rd.GetOrdinal("prec")) ? 0 : Convert.ToInt32(rd["prec"]),
									Scale = rd.IsDBNull(rd.GetOrdinal("scale")) ? 0 : Convert.ToInt32(rd["scale"]),
									Description = Convert.ToString(rd["COLUMN_DESC"]),
								}
							};

							var c = col.Column;

							switch (c.ColumnType)
							{
								case "image":
									c.Type = "byte[]";
									c.DbType = DbType.Binary;
									c.SqlDbType = SqlDbType.Image;
									break;
								case "text":
									c.Type = "string";
									c.DbType = DbType.String;
									c.SqlDbType = SqlDbType.Text;
									break;
								case "binary":
									c.Type = "byte[]";
									c.DbType = DbType.Binary;
									c.SqlDbType = SqlDbType.Binary;
									break;
								case "tinyint":
									c.Type = "byte";
									c.DbType = DbType.Byte;
									c.SqlDbType = SqlDbType.TinyInt;
									break;
								case "date":
									c.Type = "DateTime";
									c.DbType = DbType.Date;
									c.SqlDbType = SqlDbType.Date;
									break;
								case "time":
									c.Type = "DateTime";
									c.DbType = DbType.Time;
									c.SqlDbType = SqlDbType.Time;
									break;
								case "bit":
									c.Type = "bool";
									c.DbType = DbType.Boolean;
									c.SqlDbType = SqlDbType.Bit;
									break;
								case "smallint":
									c.Type = "short";
									c.DbType = DbType.Int16;
									c.SqlDbType = SqlDbType.SmallInt;
									break;
								case "decimal":
									c.Type = "decimal";
									c.DbType = DbType.Decimal;
									c.SqlDbType = SqlDbType.Decimal;
									break;
								case "int":
									c.Type = "int";
									c.DbType = DbType.Int32;
									c.SqlDbType = SqlDbType.Int;
									break;
								case "smalldatetime":
									c.Type = "DateTime";
									c.DbType = DbType.DateTime;
									c.SqlDbType = SqlDbType.SmallDateTime;
									break;
								case "real":
									c.Type = "float";
									c.DbType = DbType.Single;
									c.SqlDbType = SqlDbType.Real;
									break;
								case "money":
									c.Type = "decimal";
									c.DbType = DbType.Currency;
									c.SqlDbType = SqlDbType.Money;
									break;
								case "datetime":
									c.Type = "DateTime";
									c.DbType = DbType.DateTime;
									c.SqlDbType = SqlDbType.DateTime;
									break;
								case "float":
									c.Type = "double";
									c.DbType = DbType.Double;
									c.SqlDbType = SqlDbType.Float;
									break;
								case "numeric":
									c.Type = "decimal";
									c.DbType = DbType.Decimal;
									c.SqlDbType = SqlDbType.Decimal;
									break;
								case "smallmoney":
									c.Type = "decimal";
									c.DbType = DbType.Currency;
									c.SqlDbType = SqlDbType.SmallMoney;
									break;
								case "datetime2":
									c.Type = "DateTime";
									c.DbType = DbType.DateTime2;
									c.SqlDbType = SqlDbType.DateTime2;
									break;
								case "bigint":
									c.Type = "long";
									c.DbType = DbType.Int64;
									c.SqlDbType = SqlDbType.BigInt;
									break;
								case "varbinary":
									c.Type = "byte[]";
									c.DbType = DbType.Binary;
									c.SqlDbType = SqlDbType.VarBinary;
									break;
								case "timestamp":
									c.Type = "byte[]";
									c.DbType = DbType.Binary;
									c.SqlDbType = SqlDbType.Timestamp;
									break;
								case "sysname":
									c.Type = "string";
									c.DbType = DbType.String;
									c.SqlDbType = SqlDbType.NVarChar;
									break;
								case "nvarchar":
									c.Type = "string";
									c.DbType = DbType.String;
									c.SqlDbType = SqlDbType.NVarChar;
									break;
								case "varchar":
									c.Type = "string";
									c.DbType = DbType.AnsiString;
									c.SqlDbType = SqlDbType.VarChar;
									break;
								case "ntext":
									c.Type = "string";
									c.DbType = DbType.String;
									c.SqlDbType = SqlDbType.NText;
									break;
								case "uniqueidentifier":
									c.Type = "Guid";
									c.DbType = DbType.Binary;
									c.SqlDbType = SqlDbType.UniqueIdentifier;
									break;
								case "datetimeoffset":
									c.Type = "DateTimeOffset";
									c.DbType = DbType.DateTimeOffset;
									c.SqlDbType = SqlDbType.DateTimeOffset;
									break;
								case "sql_variant":
									c.Type = "object";
									c.DbType = DbType.Binary;
									c.SqlDbType = SqlDbType.Variant;
									break;
								case "xml":
									c.Type = "string";
									c.DbType = DbType.Xml;
									c.SqlDbType = SqlDbType.Xml;
									break;

								case "char":
									c.Type = Convert.ToInt32(rd["length"]) == 1 ? "char" : "string";
									c.DbType = DbType.AnsiStringFixedLength;
									c.SqlDbType = SqlDbType.Char;
									break;

								case "nchar":
									c.Type = Convert.ToInt32(rd["length"]) == 1 ? "char" : "string";
									c.DbType = DbType.StringFixedLength;
									c.SqlDbType = SqlDbType.NChar;
									break;

									//hierarchyid
									//geometry
									//geography
								default:
									c.Type = "byte[]";
									c.DbType = DbType.Binary;
									c.SqlDbType = SqlDbType.Binary;
									break;
							}

							switch (c.Type)
							{
								case "string":
								case "object":
								case "byte[]":
									c.IsClass = true;
									break;
							}

							if (c.IsNullable && !c.IsClass)
							{
								c.Type += "?";
							}

							columns.Add(col);
						}
					}

					// Load PKs.
					//
					s = @"
			SELECT
				(k.TABLE_CATALOG + '.' + k.TABLE_SCHEMA + '.' + k.TABLE_NAME) as id,
				k.CONSTRAINT_NAME                                             as name,
				k.COLUMN_NAME                                                 as colname,
				k.ORDINAL_POSITION                                            as colid
			FROM
				INFORMATION_SCHEMA.KEY_COLUMN_USAGE k
			  JOIN 
				INFORMATION_SCHEMA.TABLE_CONSTRAINTS c 
			  ON 
				k.CONSTRAINT_CATALOG = c.CONSTRAINT_CATALOG AND 
				k.CONSTRAINT_SCHEMA = c.CONSTRAINT_SCHEMA AND 
				k.CONSTRAINT_NAME = c.CONSTRAINT_NAME
			WHERE
				c.CONSTRAINT_TYPE='PRIMARY KEY' 
				{0}";

					if (string.IsNullOrWhiteSpace(OwnerToInclude))
					{
						cmd.CommandText = string.Format(s, "");
					}
					else
					{
						cmd.CommandText = string.Format(s, "AND k.TABLE_SCHEMA = '" + OwnerToInclude + "' ");
					}

					using (var rd = cmd.ExecuteReader())
					{
						while (rd.Read())
						{
							var id = Convert.ToString(rd["id"]);
							var colid = Convert.ToInt32(rd["colid"]);
							var colname = Convert.ToString(rd["colname"]);

							columns.Single(_ => _.ID == id && _.Column.ColumnName == colname).Column.PKIndex = colid;
						}
					}

					// Load FKs.
					//
					s = @"
			SELECT
				rc.CONSTRAINT_NAME  as Name, 
				fk.TABLE_CATALOG + '.' + fk.TABLE_SCHEMA + '.' + fk.TABLE_NAME as ThisTable,
				fk.COLUMN_NAME      as ThisColumn,
				pk.TABLE_CATALOG + '.' + pk.TABLE_SCHEMA + '.' + pk.TABLE_NAME as OtherTable,
				pk.COLUMN_NAME      as OtherColumn,
				cu.ORDINAL_POSITION as Ordinal
			FROM
				INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS rc
			  JOIN 
				INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE fk
					ON
						rc.CONSTRAINT_CATALOG        = fk.CONSTRAINT_CATALOG AND
				rc.CONSTRAINT_SCHEMA		 = fk.CONSTRAINT_SCHEMA AND
						rc.CONSTRAINT_NAME           = fk.CONSTRAINT_NAME
			  JOIN 
				INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE pk
					ON
						rc.UNIQUE_CONSTRAINT_CATALOG = pk.CONSTRAINT_CATALOG AND
				rc.UNIQUE_CONSTRAINT_SCHEMA	 = pk.CONSTRAINT_SCHEMA AND
						rc.UNIQUE_CONSTRAINT_NAME    = pk.CONSTRAINT_NAME
			  JOIN 
				INFORMATION_SCHEMA.KEY_COLUMN_USAGE cu
					ON
				rc.CONSTRAINT_CATALOG = cu.CONSTRAINT_CATALOG AND
				rc.CONSTRAINT_SCHEMA = cu.CONSTRAINT_SCHEMA AND
						rc.CONSTRAINT_NAME = cu.CONSTRAINT_NAME
			{0}
			ORDER BY
				ThisTable,
				Ordinal";

					if (string.IsNullOrWhiteSpace(OwnerToInclude))
					{
						cmd.CommandText = string.Format(s, "");
					}
					else
					{
						cmd.CommandText = string.Format(s, "WHERE fk.TABLE_SCHEMA = '" + OwnerToInclude + "' ");
					}

					using (var rd = cmd.ExecuteReader())
					{
						while (rd.Read())
						{
							var name = Convert.ToString(rd["Name"]);
							var thisTableID = Convert.ToString(rd["ThisTable"]);
							var otherTableID = Convert.ToString(rd["OtherTable"]);
							var thisColumnName = Convert.ToString(rd["ThisColumn"]);
							var otherColumnName = Convert.ToString(rd["OtherColumn"]);

							var thisTable = (from t in tables where t.ID == thisTableID select t.Table).Single();
							var otherTable = (from t in tables where t.ID == otherTableID select t.Table).Single();
							var thisColumn =
								(from c in columns where c.ID == thisTableID && c.Column.ColumnName == thisColumnName select c.Column).Single();
							var otherColumn =
								(from c in columns where c.ID == otherTableID && c.Column.ColumnName == otherColumnName select c.Column).Single();

							if (thisTable.ForeignKeys.ContainsKey(name) == false)
							{
								thisTable.ForeignKeys.Add(name, new CodeForeignKey {KeyName = name, MemberName = name, OtherTable = otherTable});
							}

							var key = thisTable.ForeignKeys[name];

							key.ThisColumns.Add(thisColumn);
							key.OtherColumns.Add(otherColumn);
						}
					}
				}
			}

			var qc =
				from c in columns
				group c by c.ID
				into gr
				join t in tables on gr.Key equals t.ID
				select new {t.Table, gr};

			foreach (var c in qc)
			{
				foreach (var col in from col in c.gr orderby col.Column.ID select col.Column)
				{
					c.Table.Columns.Add(col.ColumnName, col);
				}

				if (c.Table.Owner == "dbo")
				{
					c.Table.Owner = null;
					_tables.Add(c.Table.TableName, c.Table);
				}
				else
				{
					_tables.Add(c.Table.Owner + "." + c.Table.TableName, c.Table);
				}
			}
		}

		private string ToPlural(string str)
		{
			var word = GetLastWord(str);
			var newWord = Plurals.ToPlural(word);

			if (word != newWord)
			{
				if (char.IsUpper(word[0]))
				{
					newWord = char.ToUpper(newWord[0]) + newWord.Substring(1, newWord.Length - 1);
				}

				return word == str ? newWord : str.Substring(0, str.Length - word.Length) + newWord;
			}

			return str;
		}

		private string ToSingular(string str)
		{
			if (str.ToLowerInvariant().EndsWith("ess"))
			{
				return str;
			}

			var word = GetLastWord(str);
			var newWord = Plurals.ToSingular(word);

			if (word != newWord)
			{
				if (char.IsUpper(word[0]))
				{
					newWord = char.ToUpper(newWord[0]) + newWord.Substring(1, newWord.Length - 1);
				}

				return word == str ? newWord : str.Substring(0, str.Length - word.Length) + newWord;
			}

			return str;
		}

		private string GetLastWord(string word)
		{
			if (string.IsNullOrEmpty(word))
			{
				return word;
			}

			var len = word.Length;
			var n = len - 1;

			if (char.IsLower(word[n]))
			{
				for (; n > 0 && char.IsLower(word[n]); n--)
				{
					;
				}
			}
			else
			{
				for (; n > 0 && char.IsUpper(word[n]); n--)
				{
					;
				}
				if (char.IsLower(word[n]))
				{
					n++;
				}
			}

			return n > 0 ? word.Substring(n) : word;
		}
	}
}